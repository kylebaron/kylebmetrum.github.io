[
["index.html", "mrgsolve Users Guide Chapter 1 mrgsolve Users Guide 1.1 Session Info", " mrgsolve Users Guide Metrum Research Group, LLC 2016-05-02 Chapter 1 mrgsolve Users Guide For more information: http://www.github.com/metrumresearchgroup/mrgsolve ## [1] &quot;Mon May 2 17:58:58 2016&quot; 1.1 Session Info ## Session info -------------------------------------------------------------- ## setting value ## version R version 3.2.3 (2015-12-10) ## system x86_64, darwin13.4.0 ## ui RStudio (0.99.878) ## language (EN) ## collate en_US.UTF-8 ## tz America/Chicago ## date 2016-05-02 ## Packages ------------------------------------------------------------------ ## package * version date source ## assertthat 0.1 2013-11-08 local ## bookdown 0.0.70 2016-04-30 Github (rstudio/bookdown@82aed3e) ## DBI 0.3.1 2014-09-24 CRAN (R 3.1.1) ## devtools 1.10.0 2016-01-23 CRAN (R 3.2.1) ## digest 0.6.9 2016-01-08 CRAN (R 3.2.1) ## dplyr * 0.4.3 2015-09-01 CRAN (R 3.2.1) ## evaluate 0.8.3 2016-03-05 CRAN (R 3.2.3) ## formatR 1.3 2016-03-05 CRAN (R 3.2.3) ## htmltools 0.3.5 2016-03-21 CRAN (R 3.2.3) ## httpuv 1.3.3 2015-08-04 CRAN (R 3.1.2) ## knitr 1.12.27 2016-04-30 Github (yihui/knitr@77de0a4) ## lattice 0.20-33 2015-07-14 CRAN (R 3.2.3) ## lazyeval 0.1.10 2015-01-02 CRAN (R 3.1.2) ## magrittr 1.5 2014-11-22 CRAN (R 3.1.2) ## memoise 1.0.0 2016-01-29 CRAN (R 3.2.1) ## mime 0.4 2015-09-03 CRAN (R 3.2.1) ## miniUI 0.1.1 2016-01-15 CRAN (R 3.2.3) ## mrgsolve * 0.5.12.9000 2016-05-02 local ## R6 2.1.2 2016-01-26 CRAN (R 3.2.3) ## Rcpp 0.12.4 2016-03-26 CRAN (R 3.2.3) ## rmarkdown 0.9.6 2016-04-30 Github (rstudio/rmarkdown@e07c5f6) ## rsconnect 0.4.2.2 2016-04-30 Github (rstudio/rsconnect@aac8077) ## rstudioapi 0.5 2016-01-24 CRAN (R 3.2.1) ## servr * 0.4 2016-04-15 CRAN (R 3.2.5) ## shiny 0.13.2 2016-03-28 CRAN (R 3.2.4) ## stringi 1.0-1 2015-10-22 CRAN (R 3.2.1) ## stringr 1.0.0 2015-04-30 CRAN (R 3.1.3) ## xtable 1.8-2 2016-02-05 CRAN (R 3.2.1) ## yaml 2.1.13 2014-06-12 CRAN (R 3.0.2) "],
["intro.html", "Chapter 2 Introduction", " Chapter 2 Introduction An introduction to mrgsolve. "],
["installation.html", "Chapter 3 Installation 3.1 Installing packages in R 3.2 Required packages 3.3 Suggested packages 3.4 Compilers 3.5 Windows users 3.6 Mac OSX users 3.7 Unix users 3.8 Example installation code 3.9 Upgrading to a new version", " Chapter 3 Installation 3.1 Installing packages in R See https://cran.r-project.org/web/packages/ or R&gt; help(&quot;INSTALL&quot;) or R&gt; help(&quot;install.packages&quot;) for help. 3.2 Required packages The following required packages must be installed before installing mrgsolve: BH Rcpp RcppArmadillo dplyr All of these required packages are available on CRAN. mrgsolve imports from dplyr and links to BH, Rcpp, and RcppArmadillo. For the purposes of this document, they will be referred to as dependencies insofar as they are required to install and run mrgsolve. But note well that they are not technically dependencies the way R uses that term. Only the package namespaces and not the packages themselves will be loaded when mrgsolve is loaded. There are minimum version numbers for each dependency. R will issue an error during mrgsolve installation if insufficient versions of dependencies are currently installed. See the DESCRIPTION file in the .tar.gz archive for minimum dependency version numbers. Also, note that each required package with respect to mrgsolve may have requirements of their own. Install all required packages and their requirements as well prior to installing mrgsolve. NOTE: Rcpp and RcppArmadillo must be installed from source packages (e.g. install.packages(&quot;Rcpp&quot;, type=&quot;source&quot;)). Also, whenever new versions of Rcpp, RcppArmadillo or mrgsolve are installed, it is good practice to re-install / re-compile all three of these packages (see Compilers below). 3.3 Suggested packages These packages may be needed to perform certain tasks in mrgsolve: lattice testthat XML R users usually already have lattice installed on their system. testthat and XML are only required for a few tasks and the majority of the simulation work can be done without them. 3.4 Compilers Current versions of C++ and FORTRAN compilers are required to use mrgsolve. Available compilers and requirements may vary by operating system, but the toolchain that needs to be in place is the usual toolchain required for ordinary use of R (either to compile R from source or to compile R packages from source). There is very detailed and complete information on compilers to use with R on the r-project website (https://cran.r-project.org/doc/manuals/R-admin.html and see links below). There are no special compiler requirements to get mrgsolve up and running; just install the compilers you would normally need to use with R and mrgsolve will compile and you will be able to compile your mrgsolve models. The compilers will be used to compile C++ and FORTRAN code inside the mrgsolve package as well as user-created models. It is imperative that mrgsolve be compiled with the same compiler used to compile the user-created model. If different compilers are used, it is likely that a segmentation fault will happen. This behavior would be expected when different compilers are used. 3.5 Windows users See https://cran.r-project.org/doc/manuals/R-admin.html#The-Windows-toolset. Read this entire appendix very carefully. Follow the link to the Rtools website (https://cran.r-project.org/bin/windows/Rtools/) and read that page carefully as well. 3.6 Mac OSX users 3.6.1 If using R binary from CRAN A suitable C++ compiler is available in Xcode (https://developer.apple.com/xcode/). Be sure to download and install command line tools (bash$ xcode-select --install). Always use the most up to date version. Xcode does not include a FORTRAN compiler. There are different FORTRAN compiler requirements for Snow Leopard or Mavericks (or greater) R builds. See the platform-specific FAQs below. Carefully read the following for information: https://cran.r-project.org/doc/manuals/R-admin.html#OS-X https://cran.r-project.org/doc/manuals/R-admin.html#Mavericks-and-later To get gfortran for Mac OSX specificially, first please note if you are using a Mavericks build or Snow Leopard build (your choice of gfortran compiler will depend on this). gfortran for Mavericks build: https://r.research.att.com/libs/gfortran-4.8.2-darwin13.tar.bz2 And see: https://cran.r-project.org/doc/manuals/R-admin.html#FOOT54 gfortran for Snow Leopard build: gfortran-4.2.3.dmg at https://cran.r-project.org/bin/macosx/tools/ 3.6.2 If using R installed from homebrew We recommend and support using the CRAN binary and toolchain, but we understand that a pure homebrew implementation (R and toolchain) has worked. The key seems to be matching the homebrew R install with the homebrew gcc install. If you are using the homebrew approach, please contact personnel from that project for help with compiler issues. 3.7 Unix users UNIX usually include C++ and FORTRAN compliers. If not, install gcc. 3.8 Example installation code 3.8.1 Setup Point the installation to your favorite CRAN repository: repos &lt;- &quot;http://cran.us.r-project.org&quot; 3.8.2 Install dependencies This little function will ensure that source packages are installed from CRAN; do NOT install binary packages. install &lt;- function(x,...) install.packages(x,type=&quot;source&quot;,repos=repos,...) Install dependencies: install(&quot;Rcpp&quot;) install(&quot;RcppArmadillo&quot;) install(&quot;BH&quot;) install(&quot;dplyr&quot;) 3.8.3 Install mrgsolve To install version 0.5.11 from the source tarball, run: install.packages(&quot;mrgsolve_0.5.11.tar.gz&quot;, repos=NULL, type=&quot;source&quot;) Note that repos is set to NULL and we are telling R that the package is source, not binary. Also, we assume that the mrgsolve_0.5.11.tar.gz file is in the current working directory. To install other versions of mrgsolve, use the appropriate version number in for the tarball that you are trying to install (e.g. mrgsolve_a.b.xyz.tar.gz). 3.8.4 Test the installation library(mrgsolve) ?mrgsolve example(&quot;mrgsolve&quot;) 3.9 Upgrading to a new version Users are encouraged to re-install or re-compile Rcpp and RcppArmadillo prior to upgrading to a new version of mrgsolve. To upgrade mrgsolve, simply follow the install step above. © 2016 Metrum Research Group, LLCwww.metrumrg.com "],
["model-components.html", "Chapter 4 Model components 4.1 Parameter list 4.2 Compartment list 4.3 Simulation time grid 4.4 Solver settings 4.5 Functions 4.6 Random effect variances", " Chapter 4 Model components This chapter details the different components of a model in mrgsolve. 4.1 Parameter list The parameter list is an updatable set of name-value pairs. Referencing the name of an item in the parameter list will substitute the current value associated with that name. While the name “paramter” may have a certain connotation in the modeling world, in mrgsolve a “parameter” could be any category of numeric data: covariates (e.g. WT, AGE, SEX), flags, other numeric data that we commonly call “parameter” (e.g. CL or VC). The parameter list is declared in the code block $PARAM. While there may be multiple $PARAM blocks in a model, these are condensed to a single parameter list stored in the model object. The names and numbers of all parameters in the model must be declared at the time that the model is compiled. Also, a default value for each parameter must be declared at model compile time, but the value of each parameter may be updated in one of several ways. The parameters in a model object can be queried or updated with the param() function. 4.1.1 Central role of parameters in planning simulations The data items in the parameter list are more than just values associated with a name. When an name is added to the parameter list, that name becomes a key word that mrgsolve will start to recognize in input data sets or when manipulting the model object. For example, when you want to include a covariate in the model, say weight (WT), you’ll include a column in the data set called WT that will indicate the weight of this or that patient. It is crutial that you also list WT in $PARAM with some default value. It helps if that value is sensible too. When mrgsolve receives the data set prior to simulating, the WT column is matched up with the WT parameter name. As mrgsolve works its way through the input data set (from person to person or from time to time), the value of WT is updated so that the symbol WT in $MAIN or $ODE or $TABLE always points to the value of WT. If the WT name is not in the parameter list, it won’t matter if it is in the data set or not. Only listing a name in $PARAM gets it “into the game”. Understanding the parameter update mechanism is very important for planning complicated simulations with mrgsolve. Please review the information in 6.1 and in 8.2. 4.2 Compartment list Like the parameter list, the compartment list is a series of name-value pairs. The compartment list defines the number, names, and initial values of each compartment in the model. The names, numbers, and order of the compartment in a model is established at the time of model compile and changes to the compartment list require re-compilation of the model. Compartments are declared in one of two code blocks: $INIT and $CMT. Nominal initial values must be supplied for each compartment. The main difference between $INIT and $CMT is that $CMT assumes a default initial value of 0 for each compartment; thus only compartment names are entered. When using $INIT, both names and values must be explicitly stated for each compartment. The initial values for each compartment can be queried with the init() function. There are several different ways to set the initial conditions in a model. 4.3 Simulation time grid The mrgsolve model object stores the parameters for the series of time points to be output for a a simulation. This is the default output time grid that will be used if not over-ridden by another mechanism. The elements of the simulation time grid are: start, end, delta and add. start, end, delta are passed to seq() as from, to, and by, respectively. add is any arbitrary vector of __add__itional times to simulate. The simulation time grid in a model object may be queried with the stime() function or by printing the model object to the R console. 4.3.1 tgrid objects A tgrid object has start, end, delta and add attributes. This object is independent of the model object. tgrid objects may be created and combined to create complex sampling designs. 4.4 Solver settings mrgsolve uses the DLSODA solver from ODEPACK. Several of the settings for that solver are stored in the model object and passed to the solver when the problem is started. Settings include: atol, rtol, maxsteps, hmax, hmin, ixpr, mxhnil. 4.5 Functions There are three C++ functions that mrgsolve creates and manages: MAIN, ODE, TABLE. Each function is created from an entire code block in the model specification file. The user is responsible for writing correct C++ code in each of these blocks. mrgsolve will parse these blocks and augment this code with the necessary elements to create the C++ function. These functions may be specified in any order in the model specification file, but there is a specific calling order that should be recognized. During advance from time T1 to T2, first $MAIN is called, then $ODE is called repeatedly as the solver finds the values of state variables at T2, and, once the solution is found, $TABLE is called to calculate derived quantities at T2 and to specify variables that should be included in the model output. So, it is helpful to write model specification files in the order: $MAIN - before advancing the system $ODE - the system advance $TABLE - after advancing the system to remember the this calling order. But the order in which they are coded will not affect model compilation or the simulation result. 4.5.1 The $MAIN function The MAIN function gets called at least once before the the solver advances from the current time (T1) to the next time (T2). In the MAIN function, the user may: * Set initial conditions for any compartment * Derive new variables to be used in the model * Write covariate models * Add between-subject variability to quantities to structural model paramters (e.g. CL or VC). In addition to getting called once per record, the MAIN function may be called several times prior to starting the simulation run. The MAIN function is also called whenever the user queries the compartment list. 4.5.2 The $ODE function The ODE function is where the user writes the model differential equations. Any derived quantity that depends on a state variable and is used to to calculate the differentation must be calculated inside $ODE. But, this function is called repeatedly during the simulation run, so any calculation that can be moved out of $ODE (for example: to $MAIN) should be. 4.5.3 The $TABLE function The TABLE function is called after the solver advances in time. The purpose of TABLE is to allow the user to interact with the values of the state variables after advancing, potentially derive new variables, and to insert different outputs into the table of simulated results. 4.6 Random effect variances The mrgsolve model object keeps track of a arbitrary number of block matrices that are used to simulate variates from multivariate normal distributions. Users can specify OMEGA matrices for simulating between-subject random effects (one draw per individual) or SIGMA matrices for simulating within-subject random effects (one draw per observation. The user may use the revar function to query both OMEGA and SIGMA. 4.6.1 OMEGA The matrices are specified in $OMEGA blocks in the model specification file. OMEGA may be queried or updated with the omat function. 4.6.2 SIGMA The matrices are specified in $SIGMA blocks in the model specification file. SIGMA may be queried or updated by the smat function. "],
["model-specification.html", "Chapter 5 Model specification 5.1 Variables and Macros 5.2 Code blocks 5.3 Derive new variables", " Chapter 5 Model specification This chapter details the mrgsolve model specification format. 5.1 Variables and Macros In the following section, we adopt the convention that CMT stands for a compartment in the model. 5.1.1 ID The current subject identifier. 5.1.2 TIME Gives the time in the curent data set record. This is usually only used in $MAIN or $TABLE. Contrast with SOLVERTIME. 5.1.3 SOLVERTIME Gives the time of the current timestep taken by the solver. This is can only be used in $ODE. Contrast with TIME. 5.1.4 EVID EVID is an event id indicator. mrgsolve recognized the following event IDs: 0 = an observation record 1 = a bolus or infusion dose 2 = other type event 3 = system reset 4 = system reset and dose 8 = replace 5.1.5 NEWIND NEWIND is a new individual indicator, taking the following values: 0 for the first record of the data set 1 for the first record of a given individual 2 for all other records For example: $GLOBAL int counter = 0; $MAIN if(NEWIND &lt;=1) { counter = 0; } 5.1.6 ETA(n) ETA(n) is the value of the subject-level variate drawn from the model OMEGA matrix. ETA(1) through ETA(25) have default values of zero so they may be used in a model even if appropriate OMEGA matrices have not been provided. For example: $OMEGA 1 2 3 $MAIN double CL = TVCL*exp(ETA(1)); double VC = TVVC*exp(ETA(2)); double KA = TVKA*exp(ETA(3)); Here, we have a 3x3 OMEGA matrix. ETA(1), ETA(2), and ETA(3) will be populated with variates drawn from this matrix. ETA(4) through ETA(25) will be populated with zero. 5.1.7 EPS(n) EPS(n) holds the current value of the observation-level random variates drawn from SIGMA. The basic setup is the same as detailed in ETA(n). Example: $CMT CENT $PARAM CL=1, VC=20 $SIGMA labels=s(ADD,PROP) 25 0.0025 $TABLE double DV = (CENT/VC)*(1+PROP) + ADD; 5.1.8 table(name) This macro is used in $TABLE to insert derived variables or other information into the simulated data set. For example: $TABLE table(CP) = CENT/VC; In this example, a column will appear in the simulated data set that will be named CP and will take the value of the ratio of the amount in the central compartment divided by the central volume of distribution. Notice that the CP value only exists in the table map. It may be accessed on the right hand side of an expression like this: $TABLE table(CP) = CENT/VC; table(logCP) = log(table(CP)); Note also that the name of the output column will appear exactly as it does inside the table macro. So: $TABLE // DON&quot;T DO THIS // table(&quot;CP&quot;) = CENT/VC; // table(ETA(1)) = ETA(1); // DO THIS table(CP) = CENT/VC; table(ETA1) = ETA(1); 5.1.9 F_CMT For the CMT compartment, sets the bioavability fraction for that compartment. Example: $MAIN F_CENT = 0.7; 5.1.10 ALAG_CMT For the CMT compartment, sets the lag time for doses into that compartment. Example: $MAIN ALAG_CENT = 0.25; 5.1.11 R_CMT For the CMT compartment, sets the infusion rate for that compartment. The infusion rate is only set via R_CMT when rate in the data set or event object is set to -1. Example: $MAIN R_CENT = 100; 5.1.12 D_CMT For the CMT compartment, sets the infusion duration for that compartment. The infusion duration is only set via D_CMT when rate in the data set or event object is set to -2. Example: $MAIN D_CENT = 2; 5.2 Code blocks 5.2.1 $PARAM Define the parameter list in the current model. Example: $PARAM CL = 1, VC = 20, KA = 1.2 KM = 25, VMAX = 400, FLAG = 1, WT = 80 SEX = 0, N = sqrt(25) Notes: Multiple blocks are allowed Values are evaluated by the R interperter See also: section 5.2.13 and 5.2.2. 5.2.2 $FIXED Like $PARAM, $FIXED is used to specify name=value pairs. Unlike $PARAM, however, the values associated with names in $FIXED are not able to be updated. By default, names in $FIXED are associated with their value through a C++ preprocessor #define statement. Usually, $FIXED is only used when there are a very large number of parameters (\\(&gt;\\) 100 or 200). When some of these parameters never need to be updated, you can move them to a $FIXED block to get a modest gain in efficiency of the simulation. Items in $FIXED will not be shown when parameters are queried. Example: $PARAM CL = 2, VC = 20 $FIXED g = 9.8 See also: section 5.2.1 and 5.2.13. Notes: Multiple blocks are allowed Values are evaluated by the R interpreter 5.2.3 $CMT and $INIT Declare the names of all compartments in the model. For $CMT give the names of compartments; initial values are assumed to be 0 For $INIT give the name and initial value for all compartments Examples: $CMT GUT CENT RESPONSE $INIT GUT = 0, CENT = 0, RESPONSE = 25 5.2.4 $MAIN This code block has two main purposes: * derive new algebraic relationships between parameters, random, effects and other derived variables * Set the initial conditions for model compartments. For users who are familiar with NONMEM, $MAIN is similar to $PK. $MAIN is wrapped into a C++ function and compiled / loaded by mrgsolve. The MAIN function gets called just prior to advancing the system from the current time to the next time for each record in the data set. $MAIN also gets called several times before starting the problem (NEWIND == 0) and just prior to simulating each individual (NEWIND == 1). Finally, $MAIN gets called every time the model initial conditions are queried with init(). New variables may be declared in $MAIN. See section 5.3 for details. Examples: $CMT CENT RESP $PARAM KIN = 100, KOUT = 2, CL = 1, VC = 20 $MAIN RESP_0 = KIN/KOUT; double ke = CL/VC; 5.2.5 $ODE Use $ODE to define model differential equations. For all compartments assign the value of the differential equation to dxdt_CMT where CMT is the name of the compartment. The dxdt_ equation may be a function of model parameters (via $PARAM), the current value of any compartment (CMT) or any user-derived variable. For example: $CMT GUT CENT $ODE dxdt_GUT = -KA*GUT; dxdt_CENT = KA*GUT - KE*CENT; It is important to make sure that there is a dxdt_ expression defined for every compartment listed in $CMT or $INIT, even if it is dxdt_CMT = 0; The $ODE function is called repeatedly during a simulation run. So it is wise to do as many calculations as possible outside of $ODE, usually in $MAIN. But remember that any calculation that depends on an amount in a compartment and helps determine the dxdt_ expression in a model must be written in $ODE. New variables may be declared in $ODE. See section 5.3 for details. For example: $CMT CENT RESP $PARAM VC = 100, KE = 0.2, KOUT = 2, KIN = 100 $ODE double CP = CENT/VC; double INH = CP/(IMAX+CP) dxdt_CENT = -KE*CENT; dxdt_RESP = KIN*(1 - INH) - RESP*KOUT; If the model needs to refer to the current time, use the SOLVERTIME variable. Notes: $ODE is written in C++ syntax; every line must end in ; There may be only one $ODE block in a model 5.2.6 $TABLE Use $TABLE to interact with parameters, compartment values, and other user-defined variables after the system advances to the next time. The value associated with any symbol may be inserted into the simulated output with the table() macro. For example: $TABLE table(CP) = CENT/VC; This construct inserts a column called CP into the simulated output, calculated for each record based on the values of the amount in the central compartment (CENT) and the parameter (or variable) VC. 5.2.7 $CAPTURE A convenience block to quickly identify variables that should be captured in the simulated output. For example: $PARAM A = 1, B = 2 $MAIN double C = 3; bool yes = true; $CAPTURE A B C yes This construct will result in 4 additional columns in the simulated output with names A, B, C, and yes. The $CAPTURE block is translated to the following code: $PARAM A = 1, B = 2 $MAIN double C = 3; bool yes = true; // $CAPTURE A B C yes // inserts the following code at the end of $TABLE table(A) = A; table(B) = B; table(C) = C; table(yes) = yes; New variables may be declared in $TABLE. See section 5.3 for details. 5.2.8 $OMEGA See ?modMATRIX for more details about options for this block. Use this block to enter matrices for subject-level random effects drawn from multivariate normal distribution. By default, a diagonal matrix is assumed. So: $OMEGA 1 2 3 will generate a 3x3 omega matrix. A block matrix may be entered by using block=TRUE. So: $OMEGA block = TRUE 0.1 0.02 0.3 will generate a 2x2 matrix with covariance 0.02. A 2x2 matrix where the off-diagonal element is a correlation, not a covariance can be specified like this: $OMEGA correlation = TRUE 0.1 0.67 0.3 Here, the correlation is 0.67. mrgsolve will calculate the covariances and substitute these values. The matrix will be stored and used with these covariances, not the correlation. A name can be assigned to each matrix: $OMEGA name = &quot;PK&quot;, block=TRUE 0.2 0.02 0.3 $OMEGA name=&quot;PD&quot; 0.1 0.2 0.3 0.5 to distinguish between multiple $OMEGA blocks and to facilitate updating later. The model in the preceeding example will have two $OMEGA matrices: 2x2 and 4x4. Notes: Multiple $OMEGA blocks are allowed 5.2.9 $SIGMA See ?modMATRIX for more details about options for this block. Use this block to enter matrices for within-subject random effects drawn from multivariate normal distribution. The $SIGMA block functions like the $OMEGA block. See $OMEGA for details. 5.2.10 $SET Use this code block to set different options for the simulation. Use a name=value format, where value is evaluated by the R interpreter. Most of the options that can be entered in $SET are passed to update. For example: $SET end = 240, delta=0.5, req=s(RESP) Here, we set the simulation end time to 240, set the time difference between two adjacent time points to 0.25 time units, and request only the RESPonse compartment in the simulated output. 5.2.11 $GLOBAL The $GLOBAL block is for writing C++ code that is outside of $MAIN, $ODE, and $TABLE. There are no artificial limit on what sort of C++ code can go in $GLOBAL. However there are two more-common uses: Write #define preprocessor statements Define global variables, usually variables other than double, bool, int (see 5.3) Preprocessor directives Preprocessor #define directives are direct substibutions that the C++ preprocessor makes prior to compiling your code. For example: $GLOBAL #define CP (CENT/VC) When this preprocessor directive is included, everywhere the preprocessor finds a CP token it will substitute (CENT/VC). Both CENT and VC must be defined and the ratio of CENT to VC will be calculated depending on whatever the current values are. Notice that we included parentheses around (CENT/VC). This makes sure the ratio between the two is taken first, before any other operations involving CP. Declaring global variables Sometimes, you may wish to use global variables and have more control over how they get declared. $GLOBAL bool cure = false; With this construct, the boolean variable cure is declared and defined right as the model is compiled. 5.2.12 $PKMODEL This code block implements a one- or two-compartment PK model where the system is calculated by algebraic equations, not ODEs. mrgsolve handles the calculations and an error is generated if both $PKMODEL and $ODE blocks are included in the same model specification file. This is an options-only block. The user must specify the number of compartments (1 or 2) to use in the model as well as whether or not to include a depot dosing compartment. See ?PKMODEL for more details about this block, including specific requirements for symbols that must be defined in the model specification file. The $CMT or $INIT block must also be included with an appropriate number of compartments. Compartment names, however, may be determined by the user. Example: $CMT GUT CENT PERIPH $PKMODEL ncmt=2, depot=TRUE 5.2.13 $THETA Use this code block as an efficient way to add to the parameter list where names are determined by a prefix and a number. By default, the prefix is THETA and the number sequentially numbers the input values. For example: $THETA 0.1 0.2 0.3 is equivalent to $PARAM THETA1 = 0.1, THETA2 = 0.2, THETA3 = 0.3 See also: 5.2.13 . 5.3 Derive new variables New C++ variables may be derived in $GLOBAL, $MAIN, $ODE and $TABLE. Because these are C++ variables, the type of variable being used must be declared. For the vast majority of applications, the double type is used (double-precision numeric value. $MAIN double CLi = TVCL*exp(ETA(1)); We want CLi to be a numeric value, so we use double. To derived a boolean variable, write $MAIN bool cure = false; When variables of the type double, int, and bool are declared and initialized in $MAIN, $ODE, $TABLE, mrgsolve will detect those declarations, and modify the code so that the variables are actually declared in $GLOBAL not in $MAIN, $ODE, or $TABLE. This is done so that variables declared in one code block can be read and modified in another code block. For example, the following code: $MAIN double CLi = TVCL*exp(ETA(1)); gets translated to: $GLOBAL double CLi; $MAIN CLi = TVCL*exp(ETA(1)); This way, we can still read CLi in $TABLE: $MAIN double CLi = TVCL*exp(ETA(1)); double VCi = TVVC*exp(ETA(2)); $TABLE table(KEi) = CLi/VCi; To declare a variable that is local to a particular code block: $MAIN localdouble CLi = TVCL*exp(ETA(1)); "],
["input-data-sets.html", "Chapter 6 Input data sets 6.1 Overview 6.2 Event data sets 6.3 Individual data sets 6.4 Data sets, the parameter list and parameter updates 6.5 Numeric data only", " Chapter 6 Input data sets Input data sets are used in mrgsolve to allow the user to specify interventions and input data items. Please see the mrgsolve help topic ?exdatasets for examples of all of the data sets discussed in this chapter. The example data sets are embedded in the mrgsolve package and may be used at any time. 6.1 Overview 6.2 Event data sets Event data sets are entered as data.frame, with one event per row. In mrgsolve documentation, we refer to these data sets as data or data_set (after the function that is used to associate the data set with the model object prior to simulation. Event data sets have several special column names that mrgsolve is always aware of: ID the subject id. This id does not need to be unique in the data_set: mrgsolve detects an new individual when the current value of ID is different from the immediate preceeding value of ID. However, we always recommend using unique ID. time states the time of the data record evid is the event id indicator. evid can take the values: 0 = observation record 1 = dosing event (bolus or infusion) 2 = other type event 3 = system reset 4 = reset and dose 8 = replace the amount in the compartment with amt amt the dose amount (if evid==1) cmt the dosing compartment number. This may also be a character value naming the compartment name rate if positive when evid=1, implements a zero-order infusion of duration amt/rate ii inter-dose interval; ii=24 means daily dosing addl additional doses; a non-zero value in addl requires non-zero ii on the same record ss steady state indicator; use 1 to implement steady-state dosing; 0 otherwise 6.2.1 Sorting The IDs in the data set can appear in any order. However, an error will be generated if time on any record is less that time on the previous record within any ID. 6.2.2 Creating data sets The expand.ev function is provided by mrgsolve to help in creating data sets of a certain style. But any R code that produces a valid data set is fine to use. 6.2.3 Example To create a data set of 3 people each receiving 250 mg every 8 hours for 12 total doses: data &lt;- expand.ev(ID=1:3, amt=250, ii=8, addl=11) data . ID amt ii addl evid cmt time . 1 1 250 8 11 1 1 0 . 2 2 250 8 11 1 1 0 . 3 3 250 8 11 1 1 0 Notice that expand.ev assumes that time is 0 and cmt is 1. To dose as a 2-hour infusion into the second compartment use: data &lt;- expand.ev(ID=1:3, amt=250, rate=125, ii=8, addl=11, cmt=2) data . ID amt rate ii addl cmt evid time . 1 1 250 125 8 11 2 1 0 . 2 2 250 125 8 11 2 1 0 . 3 3 250 125 8 11 2 1 0 Use data_set to pass the data into the problem. For example: mod &lt;- mrgsolve:::house() mod %&gt;% data_set(data) %&gt;% mrgsim(end=240) %&gt;% plot(CP~time|factor(ID)) 6.3 Individual data sets Individual data sets are entered as data.frame with one unique ID per row. In mrgsolve documentation, we refer to individual data sets s idata or idata_set to distinguish them from event data sets (see section 6.2). An idata_set looks like this: data(exidata) exidata . ID CL VC KA KOUT IC50 FOO . 1 1 1.050 47.80 0.8390 2.450 1.280 4 . 2 2 0.730 30.10 0.0684 2.510 1.840 6 . 3 3 2.820 23.80 0.1180 3.880 2.480 5 . 4 4 0.552 26.30 0.4950 1.180 0.977 2 . 5 5 0.483 4.36 0.1220 2.350 0.483 10 . 6 6 3.620 39.80 0.1260 1.890 4.240 1 . 7 7 0.395 12.10 0.0317 1.250 0.802 8 . 8 8 1.440 31.20 0.0931 4.030 1.310 7 . 9 9 2.570 18.20 0.0570 0.862 1.950 3 . 10 10 2.000 6.51 0.1540 3.220 0.699 9 Here we have an idata_set with 10 subjects, one subject per row. The ID column connects the data in each row to the data in a data_set, which also requires an ID column. The ID column is the only required column name in idata_set and ID should always be a unique identifier for that row. 6.3.1 Use case idata_set is usually helpful for implementing a batch of simulations when a data_set is not used. The batch may be as a sensitivity analysis or for population simulation. Usually, an events object is used with idata, but it is not required. Use the idata_set function to pass the data set into the problem. For example: mod &lt;- mrgsolve:::house() mod %&gt;% idata_set(exidata) %&gt;% ev(amt=100) %&gt;% mrgsim %&gt;% plot Because there were 10 subjects in the idata_set, we get 10 profiles in the output. Each “individual” or “unit” received the same 100 mg dose. We would use a data_set to assign different doses to different individuals. 6.4 Data sets, the parameter list and parameter updates 6.5 Numeric data only The data.frame holding the data_set or idata_set may have any type of data in its columns. However, only numeric data can actually get passed into the simulation engine. mrgsolve will automatically look for non-numeric columns and drop them from the data_set or idata_set with a warning. "],
["simulated-output.html", "Chapter 7 Simulated output", " Chapter 7 Simulated output "],
["topics.html", "Chapter 8 Topics 8.1 Set initial conditions 8.2 Updating parameters", " Chapter 8 Topics 8.1 Set initial conditions library(mrgsolve) library(dplyr) 8.1.1 Summary mrgsolve keeps a base list of compartments and initial conditions that you can update either from R or from inside the model specification When you use $CMT, the value in that base list is assumed to be 0 for every compartment mrgsolve will by default use the values in that base list when starting the problem When only the base list is available, every individual will get the same initial condition You can override this base list by including code in $MAIN to set the initial condition Most often, you do this so that the initial is calculated as a function of a parameter For example, $MAIN RESP_0 = KIN/KOUT; when KIN and KOUT have some value in $PARAM This code in $MAIN overwrites the value in the base list for the current ID For typical PK/PD type models, we most frequently initialize in $MAIN This is equivalent to what you might do in your NONMEM model For larger systems models, we often just set the initial value via the base list 8.1.2 Make a model only to examine init behavior Note: IFLAG is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and mrgsolve does not control the value). For this demo Compartment A initial condition defaults to 0 Compartment A initial condition will get set to BASE only if IFLAG &gt; 0 Compartment A always stays at the initial condition code &lt;- &#39; $PARAM BASE=100, IFLAG = 0 $CMT A $MAIN if(IFLAG &gt; 0) A_0 = BASE; $ODE dxdt_A = 0; &#39; mod &lt;- mread(&quot;init&quot;,tempdir(),code) Check the initial condition init(mod) . . Model initial conditions (N=1): . name value . name value . A (1) 0 | . ... . Note: We used $CMT in the model spec; that implies that the base initial condition for A is set to 0 In this chunk, the code in $MAIN doesn’t get run because IFLAG is 0 So, if we don’t update something in $MAIN the initial condition is as we set it in the base list mod %&gt;% mrgsim %&gt;% plot Next, we update the base initial condition for A to 50 Note: The code in $MAIN still doesn’t get run because IFLAG is 0 mod %&gt;% init(A = 50) %&gt;% mrgsim %&gt;% plot Now, turn on IFLAG Note: Now, that code in $MAIN gets run A_0 is set to the value of BASE mod %&gt;% param(IFLAG=1) %&gt;% mrgsim %&gt;% plot mod %&gt;% param(IFLAG=1, BASE=300) %&gt;% mrgsim %&gt;% plot 8.1.3 Example PK/PD model with initial condition Just to be clear, there is no need to set any sort of flag to set the initial condition. code &lt;- &#39; $PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5 $CMT RESP $MAIN RESP_0 = KIN/KOUT; $ODE dxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP; &#39; mod &lt;- mread(&quot;init2&quot;, tempdir(), code) The initial condition is set to 40 per the values of KIN and KOUT mod %&gt;% mrgsim %&gt;% plot Even when we change RESP_0 in R, the calculation in $MAIN gets the final say mod %&gt;% init(RESP=1E9) %&gt;% mrgsim . Model: init2.cpp . Dim: 25 x 3 . Time: 0 to 24 . ID: 1 . ID time RESP . [1,] 1 0 40 . [2,] 1 1 40 . [3,] 1 2 40 . [4,] 1 3 40 . [5,] 1 4 40 . [6,] 1 5 40 . [7,] 1 6 40 . [8,] 1 7 40 8.1.4 Remember: calling init will let you check to see what is going on It’s a good idea to get in the habit of doing this when things aren’t clear init first takes the base initial condition list, then calls $MAIN and does any calculation you have in there; so the result is the calculated initials init(mod) . . Model initial conditions (N=1): . name value . name value . RESP (1) 40 | . ... . mod %&gt;% param(KIN=100) %&gt;% init . . Model initial conditions (N=1): . name value . name value . RESP (1) 20 | . ... . 8.1.5 Set initial conditions via idata Go back to house model mod &lt;- mrgsolve:::house() init(mod) . . Model initial conditions (N=3): . name value . name value . CENT (2) 0 | RESP (3) 50 . GUT (1) 0 | . ... . Notes In idata (only), include a column with CMT_0 (like you’d do in $MAIN). When each ID is simulated, the idata value will override the base initial list for that subject. But note that if CMT_0 is set in $MAIN, that will override the idata update. idata &lt;- expand.idata(CENT_0 = seq(0,25,1)) idata %&gt;% head . ID CENT_0 . 1 1 0 . 2 2 1 . 3 3 2 . 4 4 3 . 5 5 4 . 6 6 5 out &lt;- mod %&gt;% idata_set(idata) %&gt;% mrgsim(end=40) plot(out, CENT~.) 8.2 Updating parameters "]
]
